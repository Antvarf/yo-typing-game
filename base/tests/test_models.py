from django.core.exceptions import ValidationError
from django.db import (
    transaction,
    IntegrityError,
)
from django.test import TestCase
from django.utils import timezone
from django.contrib.auth import get_user_model

from base.models import (
    Player,
    GameSession,
    GameModes,
    SessionPlayerResult,
)


class GameSessionTestCase(TestCase):
    """Test that for each GameSession row:
        * only valid gamemodes (GameModes.values) are allowed
        * name can be blank but not longer than 50 chars
        * password can't be set for public room
        * is_private is set to False when not provided
        * players_max is 0 when not provided (no restriction)
        * players_now is 0 after the session is created
        * creator of the session can be NULL if creator is anonymous
        * session_ids are unique
        * is_finished is False when creating
        * created_at
        * started_at is NULL until session is started
        * finished_at is NULL until session is finished
        * if password was set by .set_password,
          .check_password returns True for it
        * .save_results for an object works properly
    """
    def setUp(self):
        self.game_session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name="test_session_1",
        )

    def test_defaults(self):
        """Tests that when not specified:
            * is_private is set to False when not provided
            * players_max is 0 when not provided (no player limit)
            * players_now is 0 after the session is created
            * creator of the session is NULL if not specified
            * session_id is autogenerated
            * is_finished is False when creating
            * created_at is roughly equal to the moment of creation
            * started_at is NULL until session is started
            * finished_at is NULL until session is finished
        """
        stamp_before = timezone.now()
        session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name="Default session"
        )
        stamp_after = timezone.now()
        self.assertFalse(session.is_private)
        self.assertEqual(session.players_max, 0)
        self.assertEqual(session.players_now, 0)
        self.assertIsNone(session.creator)
        self.assertLessEqual(stamp_before, session.created_at)
        self.assertLessEqual(session.created_at, stamp_after)
        self.assertIsNone(session.started_at)
        self.assertIsNone(session.finished_at)

    def test_gamemodes(self):
        """Test that mode field:
            * accepts defined values for GameMode
            * doesn't accept blank values
            * doesn't accept values longer than 1
            * doesn't accept values outside of GameMode.values
        """
        modes = GameModes.values
        for mode in modes:
            self.game_session.mode = mode
            self.game_session.full_clean()
            self.game_session.save()
        invalid_modes = ('', '`', 'mode_name_too_long')
        for mode in invalid_modes:
            with self.assertRaises(ValidationError):
                self.game_session.mode = mode
                self.game_session.full_clean()

    def test_name(self):
        """Test that name field:
            * is not required
            * can have duplicate rows
            * can't be longer than 50 characters
        """
        GameSession.objects.create(
            mode=self.game_session.mode,
        )
        GameSession.objects.create(
            name=self.game_session.name,
            mode=self.game_session.mode,
        )
        for name in ('A'*51,):
            with self.assertRaises(ValidationError):
                self.game_session.name = name
                self.game_session.full_clean()

    def test_password_constraints(self):
        """Test that:
            * password can be set for private rooms
            * password can't be set for non-private rooms
            * private room with password can be saved
        """
        self.game_session.is_private = True
        self.game_session.password = ''
        self.game_session.full_clean()

        with self.assertRaises(ValidationError):
            self.game_session.is_private = False
            self.game_session.set_password('hehenotempty')
            self.game_session.full_clean()

        self.game_session.is_private = True
        self.game_session.set_password('password')
        self.game_session.full_clean()
        self.game_session.is_private = False  # Ensure this flag is enforced
        self.game_session.save()
        self.assertTrue(self.game_session.is_private)

    def test_check_password(self):
        """Test that:
            * password check result is True for correct passwords
            * password check result is False for incorrect passwords
        """
        password = 'hehehehe'
        wrong_password = password+'A'
        self.game_session.is_private = True
        self.game_session.set_password(password)
        self.assertTrue(self.game_session.check_password(password))
        self.assertFalse(self.game_session.check_password(wrong_password))

    def test_session_id(self):
        """Tests that session_id field:
            * Can't be assigned directly and is autogenereated
            * Doesn't allow for duplicate values
        """
        duplicate_uuid_session = GameSession(
            mode=GameModes.SINGLE,
            session_id=self.game_session.session_id,
            name='duolingo is after me',
        )
        with self.assertRaises(ValidationError):
            duplicate_uuid_session.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                duplicate_uuid_session.save()

    def test_start_game(self):
        """Tests that .start_game():
            * Sets .started_at field to timezone.now() value
            * .started_at doesn't get updated when it's not None
        """
        before_timestamp = timezone.now()
        self.game_session.start_game()
        after_timestamp = timezone.now()
        timestamp = self.game_session.started_at

        self.assertGreaterEqual(
            timestamp,
            before_timestamp,
        )
        self.assertGreaterEqual(
            after_timestamp,
            timestamp,
        )

        self.game_session.start_game()
        self.assertEqual(
            timestamp,
            self.game_session.started_at,
        )

    def test_game_over(self):
        """Tests that .game_over():
                * Sets .finished_at field to timezone.now() value,
                       .is_finished to True
            """
        self.game_session.start_game()

        before_timestamp = timezone.now()
        self.game_session.game_over()
        after_timestamp = timezone.now()

        self.assertTrue(self.game_session.is_finished)
        self.assertGreaterEqual(
            self.game_session.finished_at,
            before_timestamp,
        )
        self.assertGreaterEqual(
            after_timestamp,
            self.game_session.finished_at,
        )

    def test_game_over_fails_on_not_started_session(self):
        """If called on a session that's yet to be started, raise exception"""
        with transaction.atomic():
            with self.assertRaises(IntegrityError):
                self.game_session.game_over()

    def test_game_over_doesnt_update_already_finished_session(self):
        """If called on a session that was already finished, do nothing"""
        self.game_session.start_game()
        self.game_session.game_over()
        before_timestamp = self.game_session.finished_at
        self.game_session.game_over()

        self.assertEqual(before_timestamp, self.game_session.finished_at)

    def test_create_from_previous(self):
        """
        Test that session preserving settings from the previous
        can be created with a new mode.
        """
        stamp_before = timezone.now()
        new_session = self.game_session.create_from_previous(
            new_mode=GameModes.TUGOFWAR,
        )
        stamp_after = timezone.now()

        self.assertEqual(new_session.mode, GameModes.TUGOFWAR)
        self.assertEqual(new_session.name, self.game_session.name)
        self.assertEqual(new_session.is_private, self.game_session.is_private)
        self.assertEqual(new_session.players_now, 0)
        self.assertEqual(
            new_session.players_max,
            self.game_session.players_max,
        )
        self.assertEqual(new_session.creator, self.game_session.creator)
        self.assertEqual(new_session.is_finished, False)
        self.assertLessEqual(stamp_before, new_session.created_at)
        self.assertLessEqual(new_session.created_at, stamp_after)
        self.assertIsNone(new_session.started_at)
        self.assertIsNone(new_session.finished_at)

    def test_create_from_previous_inverse(self):
        """
        Ensures that if any fields were added to the model,
        they were accounted for in the create_from_previous function.
        """
        new_session = self.game_session.create_from_previous(
            new_mode=GameModes.TUGOFWAR,
        )
        new_session.mode = self.game_session.mode
        new_session.is_finished = self.game_session.is_finished
        new_session.created_at = self.game_session.created_at
        new_session.started_at = self.game_session.started_at
        new_session.finished_at = self.game_session.finished_at
        new_session.session_id = self.game_session.session_id
        new_session.id = self.game_session.id

        self.assertEqual(new_session, self.game_session)

    def test_create_from_previous_fails_with_unknown_mode(self):
        """
        Attempts to create a session with mode not listed
        in GameModes should raise ValidationError.
        """
        mode = '`'
        with self.assertRaises(ValidationError):
            self.game_session.create_from_previous(
                new_mode=mode,
            )

    def test_multiplayer_only_skips_single_player_sessions(self):
        single_player_session = GameSession.objects.create(
            players_max=1,
        )
        all_sessions = GameSession.objects.all()
        singleplayer_sessions = all_sessions.filter(players_max=1)
        multiplayer_sessions = all_sessions.multiplayer_only()
        single_count = singleplayer_sessions.count()
        multi_count = multiplayer_sessions.count()

        self.assertNotIn(single_player_session, multiplayer_sessions)
        self.assertEqual(all_sessions.count(), single_count + multi_count)


class GameSessionSaveResultsTestCase(TestCase):
    """
    .save_results:
        * accepts a list of dictionaries, each containing:
            - player
            - score
            - speed
            - mistake_ratio
            - is_winner
            - correct_words
            - incorrect_words
            - team_name (optional)
        * team_name is optional
        * exceptions raised on invalid or missing values
        * if at least one result is invalid, none are saved
        * on success is_finished is set True, finished_at is set roughly to now
    """
    def setUp(self):
        self.finished_game_session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name='test_session_1',
        )
        self.finished_game_session.start_game()
        self.finished_game_session.game_over()

        self.new_game_session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name='test_session_2',
        )

        self.player = Player.objects.create(
            displayed_name='test_player_1'
        )
        self.other_player = Player.objects.create(
            displayed_name='test_player_2'
        )
        self.player_result = {
            'player': self.player,
            'score': 1337,
            'speed': 0.6,
            'mistake_ratio': 0.2,
            'is_winner': True,
            'correct_words': 80,
            'incorrect_words': 16,
            'team_name': '',
        }
        self.other_player_result = {
            'player': self.other_player,
            'score': 0xdeadbeef,
            'speed': 0.6,
            'mistake_ratio': 0.25,
            'is_winner': True,
            'correct_words': 800,
            'incorrect_words': 200,
            'team_name': '',
        }
        self.results = [
            self.player_result,
            self.other_player_result,
        ]

    def test_cannot_save_results_on_not_started_session(self):
        """Results can't be saved for a session that's not started"""
        with transaction.atomic():
            with self.assertRaises(IntegrityError):
                self.new_game_session.save_results(self.results)

    def test_cannot_save_results_on_not_finished_session(self):
        """Results can't be saved for a session that's not finished"""
        self.new_game_session.start_game()
        with transaction.atomic():
            with self.assertRaises(IntegrityError):
                self.new_game_session.save_results(self.results)

    def test_single_player(self):
        self.finished_game_session.save_results([self.player_result])

        SessionPlayerResult.objects.get(**self.player_result)

    def test_multiple_players(self):
        self.finished_game_session.save_results(self.results)
        results_qs = self.finished_game_session.results.all()

        for r in self.results:
            results_qs.get(**r)

    def test_missing_parameters(self):
        required_params = ('score', 'speed', 'mistake_ratio',
                           'is_winner', 'correct_words', 'incorrect_words')
        for param in required_params:
            invalid_result = self.player_result.copy()
            invalid_result.pop(param)
            with self.assertRaises(ValidationError):
                self.finished_game_session.save_results([invalid_result])

    def test_validation_error_rollback(self):
        results = [r.copy() for r in self.results]
        results[1].pop('score')

        with self.assertRaises(ValidationError):
            self.finished_game_session.save_results(results)
        results_qs = self.finished_game_session.results.all()
        self.assertFalse(results_qs.exists())
        # additional check that player's stats were not changed
        stats = Player.objects.with_stats().get(id=self.player.id)
        self.assertEqual(stats.best_speed, 0)
        self.assertEqual(stats.best_score, 0)
        self.assertEqual(stats.avg_speed, 0)
        self.assertEqual(stats.avg_score, 0)
        self.assertEqual(stats.games_played, 0)
        self.assertEqual(stats.total_score, 0)

    def test_error_for_non_existent_players(self):
        """If player object for non-existent player is provided, raise error"""
        self.player_result['player'].id ^= 0xdeadbeef

        with self.assertRaises(ValidationError):
            self.finished_game_session.save_results([self.player_result])

    def test_save_with_extra_fields(self):
        """If extra fields are submitted in result, filter them out and save"""
        self.player_result.update({'extra_field': 'Absolutely random value'})
        self.finished_game_session.save_results([self.player_result])
        self.player_result.pop('extra_field')

        SessionPlayerResult.objects.get(**self.player_result)


class SessionPlayerResultTestcase(TestCase):
    """Tests that:
        * session can't be NULL (is required)
        * player can't be NULL (is required)
        * session and player pointers are unique together
        * team_name can be blank, can't be longer than 50 characters
        * score can have negative and positive values
        * score is required
        * speed can't have negative values
        * mistake ratio can't have negative values
        * is_winner accepts True or False
        * correct_words, incorrect_words can't have negative values
        * results are deleted with the deletion of session
        * result player field is nullified if player is deleted
    """
    def setUp(self):
        self.player = Player.objects.create(displayed_name="test_player_1")
        self.session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name='test_session_1',
        )
        self.player2 = Player.objects.create(displayed_name="test_player_2")
        self.session2 = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name='test_session_2',
        )
        self.result = SessionPlayerResult.objects.create(
            session=self.session,
            player=self.player,
            score=0,
            speed=0,
            mistake_ratio=0,
            is_winner=True,
            correct_words=0,
            incorrect_words=0,
        )
        self.result2 = SessionPlayerResult.objects.create(
            session=self.session2,
            player=self.player2,
            score=0,
            speed=0,
            mistake_ratio=0,
            is_winner=True,
            correct_words=0,
            incorrect_words=0,
        )

    def test_session_field(self):
        """
            * Session field can't be NULL and is required
        """
        self.result.session = None
        with self.assertRaises(ValidationError):
            self.result.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                self.result.save()

    def test_player_field(self):
        """
            * Player field can't be NULL
        """
        self.result.player = None

        with self.assertRaises(ValidationError):
            self.result.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                self.result.save()

    def test_unique_session_player(self):
        """
            * session and player should be unique together
        """
        self.result2.player = self.result.player
        self.result2.session = self.result.session
        with self.assertRaises(ValidationError):
            self.result2.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                self.result2.save()

        self.result2.player = self.player2
        self.result2.session = self.session
        self.result2.full_clean()
        self.result2.save()

        self.result2.player = self.player
        self.result2.session = self.session2
        self.result2.full_clean()
        self.result2.save()

    def test_team_name_field(self):
        good_names = ('', 'Weskers', 'A'*50)
        bad_names = ('A'*51,)
        for team_name in good_names:
            self.result.team_name = team_name
            self.result.full_clean()
            self.result.save()
        for team_name in bad_names:
            self.result.team_name = team_name
            with self.assertRaises(ValidationError):
                self.result.full_clean()
            # Database-enforced max_length doesn't work with sqlite3
            # with self.assertRaises(IntegrityError):
            #     with transaction.atomic():
            #         self.result.save()

    def test_score_required(self):
        result = SessionPlayerResult(
            session=self.session,
            player=self.player,
            speed=0,
            mistake_ratio=0,
            is_winner=True,
            correct_words=0,
            incorrect_words=0,
        )
        with self.assertRaises(ValidationError):
            result.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                result.save()

    def test_score_values(self):
        for score in (-9000, 0, 9000):
            self.result.score = score
            self.result.full_clean()
            self.result.save()

    def test_speed_values(self):
        good_values = (0, 5, 9000)
        bad_values = (-1, -1000)
        for speed in good_values:
            self.result.speed = speed
            self.result.full_clean()
            self.result.save()
        for speed in bad_values:
            self.result.speed = speed
            with self.assertRaises(ValidationError):
                self.result.full_clean()
            with self.assertRaises(IntegrityError):
                with transaction.atomic():
                    self.result.save()

    def test_mistake_ratio(self):
        good_values = (0, 1, 3)
        bad_values = (-0.1, -1)
        for ratio in good_values:
            self.result.mistake_ratio = ratio
            self.result.full_clean()
            self.result.save()
        for ratio in bad_values:
            self.result.mistake_ratio = ratio
            with self.assertRaises(ValidationError):
                self.result.full_clean()
            with self.assertRaises(IntegrityError):
                with transaction.atomic():
                    self.result.save()

    def test_cascade_delete_from_session(self):
        """Delete session, check."""
        session = self.result.session
        session.delete()
        results = SessionPlayerResult.objects.filter(session=session)
        self.assertFalse(results.exists())

    def test_cascade_delete_on_player_delete(self):
        """Delete player, check."""
        player = self.result.player
        player.delete()

        with self.assertRaises(SessionPlayerResult.DoesNotExist):
            with transaction.atomic():
                SessionPlayerResult.objects.get(id=self.result.id)

    # def test_correct_words(self):
    #     good_values = (0, 1, 3, 1024)
    #     bad_values = (-0.1, -1)
    #     for word_count in good_values:
    #         self.result.correct_words = word_count
    #         self.result.full_clean()
    #         self.result.save()
    #     for word_count in bad_values:
    #         self.result.correct_words = word_count
    #         with self.assertRaises(ValidationError):
    #             self.result.full_clean()
    #         with self.assertRaises(IntegrityError):
    #             with transaction.atomic():
    #                 self.result.save()
    #
    # def test_incorrect_words(self):
    #     good_values = (0, 1, 3, 1024)
    #     bad_values = (-0.1, -1)
    #     for word_count in good_values:
    #         self.result.incorrect_words = word_count
    #         self.result.full_clean()
    #         self.result.save()
    #     for word_count in bad_values:
    #         self.result.incorrect_words = word_count
    #         with self.assertRaises(ValidationError):
    #             self.result.full_clean()
    #         with self.assertRaises(IntegrityError):
    #             with transaction.atomic():
    #                 self.result.save()


class PlayerTestCase(TestCase):
    """Tests for Player model"""
    def setUp(self):
        User = get_user_model()
        users = [
            {"username": "test_user_1", "password": "test_user_1_password"},
        ]
        self.users = list(User.objects.create_user(**user) for user in users)

    def test_user_relation(self):
        """Test that for user field:
            * On User.create a related Player object is created with
              player.displayed_name set to user.username
            * .user field values are unique, except for NULL case
        """
        for user in self.users:
            player = Player.objects.get(user=user)
            self.assertEqual(player, user.player)
            self.assertEqual(player.displayed_name, user.username)
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                Player.objects.create(
                    displayed_name="A",
                    user=self.users[0],
                )

        Player.objects.create(displayed_name="C")
        Player.objects.create(displayed_name="D")

    def test_displayed_name(self):
        """Test that for displayed_name field:
            * Minimum length allowed is 1
            ? Maximum length allowed is 50
            * Duplicates are allowed
        """
        p1 = Player.objects.create(displayed_name="A")
        Player.objects.create(displayed_name=p1.displayed_name)
        p2 = Player.objects.create(displayed_name="A"*50)
        with self.assertRaises(ValidationError):
            p1.displayed_name = ""
            p1.full_clean()
        with self.assertRaises(ValidationError):
            p2.displayed_name += "A"
            p2.full_clean()

    def test_stats_creation(self):
        """Tests that for every player created:
            * Initial stats for each category are zero
        """
        def stats_equal_zero(stats):
            return not any([
                stats.avg_score,
                stats.avg_speed,
                stats.best_score,
                stats.best_speed,
                stats.games_played,
                stats.total_score,
            ])
        player = Player.objects.create(displayed_name="A")
        player_qs = Player.objects.filter(pk=player.pk)

        general_stats = player_qs.with_stats().get()
        self.assertTrue(stats_equal_zero(general_stats))

        modes = GameModes.values
        for mode in modes:
            mode_stats = player_qs.with_stats(mode=mode).get()
            self.assertTrue(stats_equal_zero(mode_stats))


class PlayerStatsTestCase(TestCase):
    """
    Test .with_stats() and .authenticated_only() queryset methods of Player
    """
    @staticmethod
    def generate_session_results(players, sessions):
        results = [
            SessionPlayerResult(
                player=player,
                session=session,
                score=session.id * player.id,
                speed=session.id * 0.75 * player.id,
                mistake_ratio=session.id * 0.5 * player.id,
                correct_words=session.id * 100 * player.id,
                incorrect_words=session.id * 50 * player.id,
                is_winner=player is players[0],
            )
            for player in players
            for session in sessions
        ]
        SessionPlayerResult.objects.bulk_create(results, batch_size=1000)
        return results

    @staticmethod
    def stats_match_results(stats, results) -> bool:
        """Compares all stats with the ones calculated over given results"""
        best_score, best_speed = 0, 0
        avg_score, avg_speed, total_score = 0, 0, 0
        games_played = len(results)
        if games_played:
            best_score = max(r.score for r in results)
            best_speed = max(r.speed for r in results)
            total_score = sum(r.score for r in results)
            avg_speed = sum(r.speed for r in results) / len(results)
            avg_score = total_score / len(results)
        # print('\nCalculated stats:')
        # print(f'\tBest score {best_score} == {stats.best_score}')
        # print(f'\tBest speed {best_speed} == {stats.best_speed}')
        # print(f'\tAvg score {avg_score} == {stats.avg_score}')
        # print(f'\tAvg speed {avg_speed} == {stats.avg_speed}')

        return all([
            best_score == stats.best_score,
            best_speed == stats.best_speed,
            avg_score == stats.avg_score,
            avg_speed == stats.avg_speed,
            games_played == stats.games_played,
            total_score == stats.total_score,
        ])

    def setUp(self):
        self.player = Player.objects.create()
        self.other_player = Player.objects.create()
        for i in range(2):
            for mode in GameModes.values:
                GameSession.objects.create(mode=mode)
        self.generate_session_results(
            sessions=GameSession.objects.all(),
            players=(
               self.player,
               self.other_player,
            ),
        )

    def test_general_stats(self):
        """
        Test that .with_stats() with no arguments calculates properly over all
        results belonging only to that specific player for any mode
        """
        stats_qs = Player.objects.with_stats().get(pk=self.player.pk)
        results_qs = SessionPlayerResult.objects.filter(player=self.player)
        self.assertTrue(self.stats_match_results(stats_qs, results_qs))

    def test_mode_stats(self):
        """
        Test that .with_stats with an existing gamemode as an argument
        calculates stats for each mode appropriately
        """
        for mode in GameModes.values:
            stats_qs = Player.objects.with_stats(mode=mode)\
                                     .get(pk=self.player.pk)
            results_qs = SessionPlayerResult.objects.filter(
                player=self.player,
                session__mode=mode,
            )
            self.assertTrue(self.stats_match_results(stats_qs, results_qs))

    def test_invalid_mode_stats(self):
        """
        Test that .with_stats() with an undefined mode as an argument
        raises ValueError
        """
        mode = '`'
        error_message = f'`{mode}` is not a defined gamemode'
        with self.assertRaisesMessage(ValueError, error_message):
            Player.objects.with_stats(mode=mode)

    def test_multiple_players(self):
        """Test that .with_stats() works on a queryset of players"""
        players = Player.objects.all().with_stats()
        for p in players:
            SessionPlayerResult.objects.filter(player=self.player)
            self.assertTrue(self.stats_match_results)

    def test_empty_players(self):
        """Test that .with_stats() keeps the empty queryset empty"""
        players = Player.objects.none()
        self.assertFalse(players.with_stats().exists())

    def test_authenticated_only_skips_anonymous_players(self):
        User = get_user_model()

        User.objects.create_user(username='test_user_1', password='h')
        anonymous_player = Player.objects.create(
            displayed_name='test_anonymous_user_1',
        )
        players = Player.objects.authenticated_only()

        for p in players:
            self.assertIsNotNone(p.user)
            self.assertNotEqual(p, anonymous_player)

        for u in User.objects.all():
            self.assertIn(u.player, players)
