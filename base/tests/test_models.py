from django.core.exceptions import ValidationError
from django.db import (
    transaction,
    IntegrityError,
)
from django.test import TestCase
from django.utils import timezone
from django.contrib.auth import get_user_model

from base.models import (
    Player,
    GameSession,
    GameModes,
)


class PlayerTestCase(TestCase):
    """Tests for Player model coverage.

    Ensures that:
        * Players with empty displayed_name cannot be created (min length == 1)
        * User pointer is unique and can be null (on multiple rows)
    """

    def setUp(self):
        User = get_user_model()
        users = [
            {"username": "test_user_1", "password": "test_user_1_password"},
        ]
        self._users = list(User.objects.create_user(**user) for user in users)

    def test_user_relation(self):
        """Test that for user field:
            * User field values are unique
            * NULL values for multiple rows are possible
        """
        player1 = Player.objects.create(displayed_name="A", user=self._users[0])
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                user_duplicate = Player.objects.create(displayed_name="B",
                                                       user=self._users[0])

        anon_player1 = Player.objects.create(displayed_name="C")
        anon_player2 = Player.objects.create(displayed_name="D")

    def test_displayed_name(self):
        """Test that for displayed_name field:
            * Minimum length allowed is 1
            ? Maximum length allowed is 50
            * Duplicates are allowed
        """
        p1 = Player.objects.create(displayed_name="A")
        p1_duplicate = Player.objects.create(displayed_name=p1.displayed_name)
        p2 = Player.objects.create(displayed_name="A"*50)
        with self.assertRaises(ValidationError):
            p1.displayed_name = ""
            p1.full_clean()
        with self.assertRaises(ValidationError):
            p2.displayed_name += "A"
            p2.full_clean()

    def test_stats_creation(self):
        """Tests that for every player created:
            * Overall stats are automatically created and properly initialized
            * For each mode stats are also created and properly initialized
        """
        def stats_equal_zero(stats):
            return not any([
                stats.avg_score,
                stats.avg_speed,
                stats.best_score,
                stats.best_speed,
                stats.games_played,
            ])
        player = Player.objects.create(displayed_name="A")
        stats_qs = player.stats.all()

        overall_stats = stats_qs.overall().get()
        self.assertTrue(stats_equal_zero(overall_stats))

        modes = GameModes.values
        for mode in modes:
            mode_stats = stats_qs.for_gamemode(mode).get()
            self.assertTrue(stats_equal_zero(mode_stats))


class GameSessionTestCase(TestCase):
    """Test that for each GameSession row:
        * only valid gamemodes (GAMEMODES_CHOICES) are allowed
        * name can't be blank or longer than 50 chars
        * password can be blank ONLY if room is not private
        * is_private is set to False when not provided
        * players_max is 0 when not provided (no restriction)
        * players_now is 0 after the session is created
        * creator of the session can be NULL if creator is anonymous
        * session_ids are unique
        * is_finished is False when creating
        * created_at
        * started_at is NULL until session is started
        * finished_at is NULL until session is finished
    """
    def setUp(self):
        self.game_session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name="Test session 1",
        )

    def test_defaults(self):
        """Tests that when not specified:
            * is_private is set to False when not provided
            * players_max is 0 when not provided (no player limit)
            * players_now is 0 after the session is created
            * creator of the session is NULL if not specified
            * session_id is autogenerated
            * is_finished is False when creating
            * created_at is roughly equal to the moment of creation
            * started_at is NULL until session is started
            * finished_at is NULL until session is finished
        """
        stamp_before = timezone.now()
        session = GameSession.objects.create(
            mode=GameModes.SINGLE,
            name="Default session"
        )
        stamp_after = timezone.now()
        self.assertFalse(session.is_private)
        self.assertEqual(session.players_max, 0)
        self.assertEqual(session.players_now, 0)
        self.assertIsNone(session.creator)
        self.assertLessEqual(stamp_before, session.created_at)
        self.assertLessEqual(session.created_at, stamp_after)
        self.assertIsNone(session.started_at)
        self.assertIsNone(session.finished_at)

    def test_gamemodes(self):
        """Test that mode field:
            * accepts defined values for GameMode
            * doesn't accept blank values
            * doesn't accept values longer than 1
            * doesn't accept values outside of GameMode.values()
        """
        modes = GameModes.values
        for mode in modes:
            self.game_session.mode = mode
            self.game_session.full_clean()
            self.game_session.save()
        invalid_modes = ('', '`', 'mode_name_too_long')
        for mode in invalid_modes:
            with self.assertRaises(ValidationError):
                self.game_session.mode = mode
                self.game_session.full_clean()

    def test_name(self):
        """Test that name field:
            * can't have duplicate rows
            * can't be blank or longer than 50 characters
        """
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                duplicate_session = GameSession.objects.create(
                    name=self.game_session.name,
                    mode=self.game_session.mode,
                )
        for name in ('', 'A'*51):
            with self.assertRaises(ValidationError):
                self.game_session.name = name
                self.game_session.full_clean()

    def test_password_constraints(self):
        """Test that:
            * password must be set for private rooms
            * password can't be set for non-private rooms
            * private room with password can be saved
        """
        with self.assertRaises(ValidationError):
            self.game_session.is_private = True
            self.game_session.password = ''
            self.game_session.full_clean()

        with self.assertRaises(ValidationError):
            self.game_session.is_private = False
            self.game_session.set_password('hehenotempty')
            self.game_session.full_clean()

        self.game_session.is_private = True
        self.game_session.set_password('password')
        self.game_session.full_clean()
        self.game_session.save()

    def test_check_password(self):
        """Test that:
            * password check result is True for correct passwords
            * password check result is False for incorrect passwords
        """
        password = 'hehehehe'
        wrong_password = password+'A'
        self.game_session.is_private = True
        self.game_session.set_password(password)
        self.assertTrue(self.game_session.check_password(password))
        self.assertFalse(self.game_session.check_password(wrong_password))

    def test_session_id(self):
        """Tests that session_id field:
            * Can't be assigned directly and is autogenereated
            * Doesn't allow for duplicate values
        """
        duplicate_uuid_session = GameSession(
            mode=GameModes.SINGLE,
            session_id=self.game_session.session_id,
            name='duolingo is after me',
        )
        with self.assertRaises(ValidationError):
            duplicate_uuid_session.full_clean()
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                duplicate_uuid_session.save()


class SessionPlayerResultTestcase(TestCase):
    pass
